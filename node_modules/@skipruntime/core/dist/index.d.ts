/**
 * The @skipruntime/core package contains internal implementation detail for the Skip Framework and should not need to be used directly. See the public API exposed by the @skipruntime/helpers package.
 *
 * @packageDocumentation
 */
import type { Opaque } from "@skiplang/std";
import type { Pointer, Nullable, Json, JsonConverter } from "@skiplang/json";
import { sk_freeze, isSkManaged } from "@skiplang/json";
import type * as Internal from "./internal.js";
import { type CollectionUpdate, type Entry, type ExternalService, type LazyCompute, type Mapper, type Reducer, type Resource, type SkipService, type Watermark } from "@skipruntime/api";
import { UnknownCollectionError } from "./errors.js";
import { ResourceBuilder, type Notifier, type Checker, type Handle, type FromBinding } from "./binding.js";
export { UnknownCollectionError, sk_freeze, isSkManaged };
export { Sum, Min, Max, Count } from "./utils.js";
export type JSONMapper = Mapper<Json, Json, Json, Json>;
export type JSONLazyCompute = LazyCompute<Json, Json>;
declare class Handles {
    private nextID;
    private readonly objects;
    private readonly freeIDs;
    register<T>(v: T): Handle<T>;
    get<T>(id: Handle<T>): T;
    apply<R, P extends any[]>(id: Handle<(..._: P) => R>, parameters: P): R;
    deleteHandle<T>(id: Handle<T>): T;
}
export declare class Stack {
    private readonly stack;
    push(pointer: Pointer<Internal.Context>): void;
    get(): Nullable<Pointer<Internal.Context>>;
    pop(): void;
}
export declare class Refs {
    readonly binding: FromBinding;
    readonly skjson: JsonConverter;
    readonly handles: Handles;
    readonly needGC: () => boolean;
    readonly runWithGC: <T>(fn: () => T) => T;
    constructor(binding: FromBinding, skjson: JsonConverter, handles: Handles, needGC: () => boolean, runWithGC: <T>(fn: () => T) => T);
}
export declare class ServiceInstanceFactory {
    private init;
    constructor(init: (service: SkipService) => ServiceInstance);
    initService(service: SkipService): ServiceInstance;
}
export type GetResult<T> = {
    request?: string;
    payload: T;
    errors: Json[];
};
export type Executor<T> = {
    resolve: (value: T) => void;
    reject: (reason?: any) => void;
};
export type SubscriptionID = Opaque<bigint, "subscription">;
/**
 * A `ServiceInstance` is a running instance of a `SkipService`, providing access to its resources
 * and operations to manage susbscriptions and the service itself.
 */
export declare class ServiceInstance {
    private readonly refs;
    constructor(refs: Refs);
    /**
     * Instantiate a resource with some parameters and client session authentication token
     * @param identifier - The resource instance identifier
     * @param resource - A resource name, which must correspond to a key in this `SkipService`'s `resources` field
     * @param params - Resource parameters, which will be passed to the resource constructor specified in this `SkipService`'s `resources` field
     */
    instantiateResource(identifier: string, resource: string, params: Json): void;
    /**
     * Creates if not exists and get all current values of specified resource
     * @param resource - the resource name corresponding to a key in remotes field of SkipService
     * @param params - the parameters of the resource used to build the resource with the corresponding constructor specified in remotes field of SkipService
     * @returns The current values of the corresponding resource with reactive responce token to allow subscription
     */
    getAll<K extends Json, V extends Json>(resource: string, params?: Json, request?: string | Executor<Entry<K, V>[]>): GetResult<Entry<K, V>[]>;
    /**
     * Get the current value of a key in the specified resource instance, creating it if it doesn't already exist
     * @param resource - A resource name, which must correspond to a key in this `SkipService`'s `resources` field
     * @param key - A key to look up in the resource instance
     * @param params - Resource parameters, passed to the resource constructor specified in this `SkipService`'s `resources` field
     * @returns The current value(s) for this key in the specified resource instance
     */
    getArray<K extends Json, V extends Json>(resource: string, key: K, params?: Json, request?: string | Executor<V[]>): GetResult<V[]>;
    /**
     * Close the specified resource instance
     * @param resourceInstanceId - The resource identifier
     */
    closeResourceInstance(resourceInstanceId: string): void;
    /**
     * Initiate reactive subscription on a resource instance
     * @param resourceInstanceId - the resource instance identifier
     * @param notifier - the object containing subscription callbacks
     * @param notifier.subscribed - A callback to execute when subscription effectivly done
     * @param notifier.notify - A callback to execute on collection updates
     * @param notifier.close - A callback to execute on resource close
     * @param watermark - the watermark where to start the subscription
     * @returns A subcription identifier
     */
    subscribe<K extends Json, V extends Json>(resourceInstanceId: string, notifier: {
        subscribed: () => void;
        notify: (update: CollectionUpdate<K, V>) => void;
        close: () => void;
    }, watermark?: string): SubscriptionID;
    /**
     * Terminate a client's subscription to a reactive resource instance
     * @param id - The subcription identifier returned by a call to `subscribe`
     */
    unsubscribe(id: SubscriptionID): void;
    /**
     * Update an input collection
     * @param collection - the name of the input collection to update
     * @param entries - entries to update in the collection.
     */
    update<K extends Json, V extends Json>(collection: string, entries: Entry<K, V>[]): void;
    /**
     * Close all resources and shut down the service.
     * Any subsequent calls on the service will result in errors.
     */
    close(): void;
}
export declare class ToBinding {
    private binding;
    private runWithGC;
    private getConverter;
    private getError;
    private readonly stack;
    private readonly handles;
    private skjson?;
    constructor(binding: FromBinding, runWithGC: <T>(fn: () => T) => T, getConverter: () => JsonConverter, getError: (skExc: Pointer<Internal.Exception>) => Error);
    register<T>(v: T): Handle<T>;
    deleteHandle<T>(id: Handle<T>): T;
    SkipRuntime_getErrorHdl(exn: Pointer<Internal.Exception>): Handle<Error>;
    SkipRuntime_pushContext(context: Pointer<Internal.Context>): void;
    SkipRuntime_popContext(): void;
    SkipRuntime_getContext(): Nullable<Pointer<Internal.Context>>;
    SkipRuntime_Mapper__mapEntry(skmapper: Handle<JSONMapper>, key: Pointer<Internal.CJSON>, values: Pointer<Internal.NonEmptyIterator>): Pointer<Internal.CJArray>;
    SkipRuntime_deleteMapper(mapper: Handle<JSONMapper>): void;
    SkipRuntime_LazyCompute__compute(sklazyCompute: Handle<JSONLazyCompute>, self: string, skkey: Pointer<Internal.CJSON>): Pointer<Internal.CJArray>;
    SkipRuntime_deleteLazyCompute(lazyCompute: Handle<JSONLazyCompute>): void;
    SkipRuntime_Resource__instantiate(skresource: Handle<Resource>, skcollections: Pointer<Internal.CJObject>): string;
    SkipRuntime_deleteResource(resource: Handle<Resource>): void;
    SkipRuntime_ResourceBuilder__build(skbuilder: Handle<ResourceBuilder>, skparams: Pointer<Internal.CJObject>): Pointer<Internal.Resource>;
    SkipRuntime_deleteResourceBuilder(builder: Handle<ResourceBuilder>): void;
    SkipRuntime_Service__createGraph(skservice: Handle<SkipService>, skcollections: Pointer<Internal.CJObject>): Pointer<Internal.CJObject>;
    SkipRuntime_deleteService(service: Handle<SkipService>): void;
    SkipRuntime_Notifier__subscribed<K extends Json, V extends Json>(sknotifier: Handle<Notifier<K, V>>): void;
    SkipRuntime_Notifier__notify<K extends Json, V extends Json>(sknotifier: Handle<Notifier<K, V>>, skvalues: Pointer<Internal.CJArray<Internal.CJArray<Internal.CJSON>>>, watermark: Watermark, isUpdates: number): void;
    SkipRuntime_Notifier__close<K extends Json, V extends Json>(sknotifier: Handle<Notifier<K, V>>): void;
    SkipRuntime_deleteNotifier<K extends Json, V extends Json>(notifier: Handle<Notifier<K, V>>): void;
    SkipRuntime_Reducer__add(skreducer: Handle<Reducer<Json, Json>>, skacc: Nullable<Pointer<Internal.CJSON>>, skvalue: Pointer<Internal.CJSON>): Pointer<Internal.CJSON>;
    SkipRuntime_Reducer__remove(skreducer: Handle<Reducer<Json, Json>>, skacc: Pointer<Internal.CJSON>, skvalue: Pointer<Internal.CJSON>): Nullable<Pointer<Internal.CJSON>>;
    SkipRuntime_deleteReducer(reducer: Handle<Reducer<Json, Json>>): void;
    SkipRuntime_ExternalService__subscribe(sksupplier: Handle<ExternalService>, writerId: string, resource: string, skparams: Pointer<Internal.CJObject>): void;
    SkipRuntime_ExternalService__unsubscribe(sksupplier: Handle<ExternalService>, resource: string, skparams: Pointer<Internal.CJObject>): void;
    SkipRuntime_ExternalService__shutdown(sksupplier: Handle<ExternalService>): void;
    SkipRuntime_deleteExternalService(supplier: Handle<ExternalService>): void;
    SkipRuntime_Checker__check(skchecker: Handle<Checker>, request: string): void;
    SkipRuntime_deleteChecker(checker: Handle<Checker>): void;
    initService(service: SkipService): ServiceInstance;
    private getJsonConverter;
    private needGC;
    private refs;
}
//# sourceMappingURL=index.d.ts.map