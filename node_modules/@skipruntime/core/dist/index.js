/**
 * The @skipruntime/core package contains internal implementation detail for the Skip Framework and should not need to be used directly. See the public API exposed by the @skipruntime/helpers package.
 *
 * @packageDocumentation
 */
import { sk_freeze, isSkManaged, SkManaged, checkOrCloneParam, } from "@skiplang/json";
import { sknative } from "@skiplang/std";
import { NonUniqueValueException, } from "@skipruntime/api";
import { UnknownCollectionError } from "./errors.js";
import { ResourceBuilder, } from "./binding.js";
export { UnknownCollectionError, sk_freeze, isSkManaged };
export { Sum, Min, Max, Count } from "./utils.js";
class Handles {
    constructor() {
        this.nextID = 1;
        this.objects = [];
        this.freeIDs = [];
    }
    register(v) {
        const freeID = this.freeIDs.pop();
        const id = freeID ?? this.nextID++;
        this.objects[id] = v;
        return id;
    }
    get(id) {
        return this.objects[id];
    }
    apply(id, parameters) {
        const fn = this.get(id);
        return fn.apply(null, parameters);
    }
    deleteHandle(id) {
        const current = this.get(id);
        this.objects[id] = null;
        this.freeIDs.push(id);
        return current;
    }
}
export class Stack {
    constructor() {
        this.stack = [];
    }
    push(pointer) {
        this.stack.push(pointer);
    }
    get() {
        if (this.stack.length == 0)
            return null;
        return this.stack[this.stack.length - 1];
    }
    pop() {
        this.stack.pop();
    }
}
export class Refs {
    constructor(binding, skjson, handles, needGC, runWithGC) {
        this.binding = binding;
        this.skjson = skjson;
        this.handles = handles;
        this.needGC = needGC;
        this.runWithGC = runWithGC;
    }
}
class LazyCollectionImpl extends SkManaged {
    constructor(lazyCollection, refs) {
        super();
        this.lazyCollection = lazyCollection;
        this.refs = refs;
        Object.freeze(this);
    }
    getArray(key) {
        return this.refs.skjson.importJSON(this.refs.binding.SkipRuntime_LazyCollection__getArray(this.lazyCollection, this.refs.skjson.exportJSON(key)));
    }
    getUnique(key) {
        const v = this.refs.skjson.importOptJSON(this.refs.binding.SkipRuntime_LazyCollection__getUnique(this.lazyCollection, this.refs.skjson.exportJSON(key)));
        if (v == null)
            throw new NonUniqueValueException();
        return v;
    }
}
class EagerCollectionImpl extends SkManaged {
    constructor(collection, refs) {
        super();
        this.collection = collection;
        this.refs = refs;
        this.size = () => {
            return Number(this.refs.binding.SkipRuntime_Collection__size(this.collection));
        };
        Object.freeze(this);
    }
    getArray(key) {
        return this.refs.skjson.importJSON(this.refs.binding.SkipRuntime_Collection__getArray(this.collection, this.refs.skjson.exportJSON(key)));
    }
    getUnique(key) {
        const v = this.refs.skjson.importOptJSON(this.refs.binding.SkipRuntime_Collection__getUnique(this.collection, this.refs.skjson.exportJSON(key)));
        if (v == null)
            throw new NonUniqueValueException();
        return v;
    }
    slice(start, end) {
        return this.slices([start, end]);
    }
    slices(...ranges) {
        const skcollection = this.refs.binding.SkipRuntime_Collection__slice(this.collection, this.refs.skjson.exportJSON(ranges));
        return this.derive(skcollection);
    }
    take(limit) {
        const skcollection = this.refs.binding.SkipRuntime_Collection__take(this.collection, BigInt(limit));
        return this.derive(skcollection);
    }
    map(mapper, ...params) {
        const mapperParams = params.map(checkOrCloneParam);
        const mapperObj = new mapper(...mapperParams);
        Object.freeze(mapperObj);
        if (!mapperObj.constructor.name) {
            throw new Error("Mapper classes must be defined at top-level.");
        }
        const skmapper = this.refs.binding.SkipRuntime_createMapper(this.refs.handles.register(mapperObj));
        const mapped = this.refs.binding.SkipRuntime_Collection__map(this.collection, skmapper);
        return this.derive(mapped);
    }
    mapReduce(mapper, ...mapperParams) {
        return (reducer, ...reducerParams) => {
            const mParams = mapperParams.map(checkOrCloneParam);
            const rParams = reducerParams.map(checkOrCloneParam);
            const mapperObj = new mapper(...mParams);
            const reducerObj = new reducer(...rParams);
            Object.freeze(mapperObj);
            Object.freeze(reducerObj);
            if (!mapperObj.constructor.name) {
                throw new Error("Mapper classes must be defined at top-level.");
            }
            if (!reducerObj.constructor.name) {
                throw new Error("Reducer classes must be defined at top-level.");
            }
            const skmapper = this.refs.binding.SkipRuntime_createMapper(this.refs.handles.register(mapperObj));
            if (sknative in reducerObj && typeof reducerObj[sknative] == "string") {
                return this.derive(this.refs.binding.SkipRuntime_Collection__nativeMapReduce(this.collection, skmapper, reducerObj[sknative]));
            }
            else {
                const skreducer = this.refs.binding.SkipRuntime_createReducer(this.refs.handles.register(reducerObj), this.refs.skjson.exportJSON(reducerObj.initial));
                return this.derive(this.refs.binding.SkipRuntime_Collection__mapReduce(this.collection, skmapper, skreducer));
            }
        };
    }
    reduce(reducer, ...params) {
        const reducerParams = params.map(checkOrCloneParam);
        const reducerObj = new reducer(...reducerParams);
        Object.freeze(reducerObj);
        if (!reducerObj.constructor.name) {
            throw new Error("Reducer classes must be defined at top-level.");
        }
        if (sknative in reducerObj && typeof reducerObj[sknative] == "string") {
            return this.derive(this.refs.binding.SkipRuntime_Collection__nativeReduce(this.collection, reducerObj[sknative]));
        }
        else {
            const skreducer = this.refs.binding.SkipRuntime_createReducer(this.refs.handles.register(reducerObj), this.refs.skjson.exportJSON(reducerObj.initial));
            return this.derive(this.refs.binding.SkipRuntime_Collection__reduce(this.collection, skreducer));
        }
    }
    merge(...others) {
        const otherNames = others.map((other) => other.collection);
        const mapped = this.refs.binding.SkipRuntime_Collection__merge(this.collection, this.refs.skjson.exportJSON(otherNames));
        return this.derive(mapped);
    }
    derive(collection) {
        return new EagerCollectionImpl(collection, this.refs);
    }
}
class CollectionWriter {
    constructor(collection, refs) {
        this.collection = collection;
        this.refs = refs;
    }
    update(values, isInit) {
        const update_ = () => {
            return this.refs.binding.SkipRuntime_CollectionWriter__update(this.collection, this.refs.skjson.exportJSON(values), isInit);
        };
        if (this.refs.needGC()) {
            this.refs.runWithGC(update_);
        }
        else {
            update_();
        }
    }
    loading() {
        const loading_ = () => {
            return this.refs.binding.SkipRuntime_CollectionWriter__loading(this.collection);
        };
        if (this.refs.needGC())
            this.refs.runWithGC(loading_);
        else
            loading_();
    }
    error(error) {
        const error_ = () => {
            return this.refs.binding.SkipRuntime_CollectionWriter__error(this.collection, this.refs.skjson.exportJSON(error));
        };
        if (this.refs.needGC())
            this.refs.runWithGC(error_);
        else
            error_();
    }
}
class ContextImpl extends SkManaged {
    constructor(refs) {
        super();
        this.refs = refs;
        Object.freeze(this);
    }
    createLazyCollection(compute, ...params) {
        const mapperParams = params.map(checkOrCloneParam);
        const computeObj = new compute(...mapperParams);
        Object.freeze(computeObj);
        if (!computeObj.constructor.name) {
            throw new Error("LazyCompute classes must be defined at top-level.");
        }
        const skcompute = this.refs.binding.SkipRuntime_createLazyCompute(this.refs.handles.register(computeObj));
        const lazyCollection = this.refs.binding.SkipRuntime_Context__createLazyCollection(skcompute);
        return new LazyCollectionImpl(lazyCollection, this.refs);
    }
    useExternalResource(resource) {
        const collection = this.refs.binding.SkipRuntime_Context__useExternalResource(resource.service, resource.identifier, this.refs.skjson.exportJSON(resource.params ?? {}));
        return new EagerCollectionImpl(collection, this.refs);
    }
    jsonExtract(value, pattern) {
        return this.refs.skjson.importJSON(this.refs.binding.SkipRuntime_Context__jsonExtract(this.refs.skjson.exportJSON(value), pattern));
    }
}
export class ServiceInstanceFactory {
    constructor(init) {
        this.init = init;
    }
    initService(service) {
        return this.init(service);
    }
}
class AllChecker {
    constructor(service, executor, resource, params) {
        this.service = service;
        this.executor = executor;
        this.resource = resource;
        this.params = params;
    }
    check(request) {
        const result = this.service.getAll(this.resource, this.params, request);
        if (result.errors.length > 0) {
            this.executor.reject(new Error(JSON.stringify(result.errors)));
        }
        else {
            this.executor.resolve(result.payload);
        }
    }
}
class OneChecker {
    constructor(service, executor, resource, params, key) {
        this.service = service;
        this.executor = executor;
        this.resource = resource;
        this.params = params;
        this.key = key;
    }
    check(request) {
        const result = this.service.getArray(this.resource, this.key, this.params, request);
        if (result.errors.length > 0) {
            this.executor.reject(new Error(JSON.stringify(result.errors)));
        }
        else {
            this.executor.resolve(result.payload);
        }
    }
}
/**
 * A `ServiceInstance` is a running instance of a `SkipService`, providing access to its resources
 * and operations to manage susbscriptions and the service itself.
 */
export class ServiceInstance {
    constructor(refs) {
        this.refs = refs;
    }
    /**
     * Instantiate a resource with some parameters and client session authentication token
     * @param identifier - The resource instance identifier
     * @param resource - A resource name, which must correspond to a key in this `SkipService`'s `resources` field
     * @param params - Resource parameters, which will be passed to the resource constructor specified in this `SkipService`'s `resources` field
     */
    instantiateResource(identifier, resource, params) {
        const errorHdl = this.refs.runWithGC(() => {
            return this.refs.binding.SkipRuntime_Runtime__createResource(identifier, resource, this.refs.skjson.exportJSON(params));
        });
        if (errorHdl)
            throw this.refs.handles.deleteHandle(errorHdl);
    }
    /**
     * Creates if not exists and get all current values of specified resource
     * @param resource - the resource name corresponding to a key in remotes field of SkipService
     * @param params - the parameters of the resource used to build the resource with the corresponding constructor specified in remotes field of SkipService
     * @returns The current values of the corresponding resource with reactive responce token to allow subscription
     */
    getAll(resource, params = {}, request) {
        const get_ = () => {
            return this.refs.skjson.importJSON(this.refs.binding.SkipRuntime_Runtime__getAll(resource, this.refs.skjson.exportJSON(params), request !== undefined
                ? typeof request == "string"
                    ? this.refs.binding.SkipRuntime_createIdentifier(request)
                    : this.refs.binding.SkipRuntime_createChecker(this.refs.handles.register(new AllChecker(this, request, resource, params)))
                : null), true);
        };
        const result = this.refs.needGC() ? this.refs.runWithGC(get_) : get_();
        if (typeof result == "number")
            throw this.refs.handles.deleteHandle(result);
        return result;
    }
    /**
     * Get the current value of a key in the specified resource instance, creating it if it doesn't already exist
     * @param resource - A resource name, which must correspond to a key in this `SkipService`'s `resources` field
     * @param key - A key to look up in the resource instance
     * @param params - Resource parameters, passed to the resource constructor specified in this `SkipService`'s `resources` field
     * @returns The current value(s) for this key in the specified resource instance
     */
    getArray(resource, key, params = {}, request) {
        const get_ = () => {
            return this.refs.skjson.importJSON(this.refs.binding.SkipRuntime_Runtime__getForKey(resource, this.refs.skjson.exportJSON(params), this.refs.skjson.exportJSON(key), request !== undefined
                ? typeof request == "string"
                    ? this.refs.binding.SkipRuntime_createIdentifier(request)
                    : this.refs.binding.SkipRuntime_createChecker(this.refs.handles.register(new OneChecker(this, request, resource, params, key)))
                : null), true);
        };
        const needGC = this.refs.needGC();
        const result = needGC ? this.refs.runWithGC(get_) : get_();
        if (typeof result == "number")
            throw this.refs.handles.deleteHandle(result);
        return result;
    }
    /**
     * Close the specified resource instance
     * @param resourceInstanceId - The resource identifier
     */
    closeResourceInstance(resourceInstanceId) {
        const errorHdl = this.refs.runWithGC(() => {
            return this.refs.binding.SkipRuntime_Runtime__closeResource(resourceInstanceId);
        });
        if (errorHdl)
            throw this.refs.handles.deleteHandle(errorHdl);
    }
    /**
     * Initiate reactive subscription on a resource instance
     * @param resourceInstanceId - the resource instance identifier
     * @param notifier - the object containing subscription callbacks
     * @param notifier.subscribed - A callback to execute when subscription effectivly done
     * @param notifier.notify - A callback to execute on collection updates
     * @param notifier.close - A callback to execute on resource close
     * @param watermark - the watermark where to start the subscription
     * @returns A subcription identifier
     */
    subscribe(resourceInstanceId, notifier, watermark) {
        const session = this.refs.runWithGC(() => {
            const sknotifier = this.refs.binding.SkipRuntime_createNotifier(this.refs.handles.register(notifier));
            return this.refs.binding.SkipRuntime_Runtime__subscribe(resourceInstanceId, sknotifier, watermark ?? null);
        });
        if (session == -1n) {
            throw new UnknownCollectionError(`Unknown resource instance '${resourceInstanceId}'`);
        }
        else if (session < 0n) {
            throw new Error("Unknown error");
        }
        return session;
    }
    /**
     * Terminate a client's subscription to a reactive resource instance
     * @param id - The subcription identifier returned by a call to `subscribe`
     */
    unsubscribe(id) {
        const errorHdl = this.refs.runWithGC(() => {
            return this.refs.binding.SkipRuntime_Runtime__unsubscribe(id);
        });
        if (errorHdl) {
            throw this.refs.handles.deleteHandle(errorHdl);
        }
    }
    /**
     * Update an input collection
     * @param collection - the name of the input collection to update
     * @param entries - entries to update in the collection.
     */
    update(collection, entries) {
        const errorHdl = this.refs.runWithGC(() => {
            return this.refs.binding.SkipRuntime_Runtime__update(collection, this.refs.skjson.exportJSON(entries));
        });
        if (errorHdl) {
            throw this.refs.handles.deleteHandle(errorHdl);
        }
    }
    /**
     * Close all resources and shut down the service.
     * Any subsequent calls on the service will result in errors.
     */
    close() {
        const errorHdl = this.refs.runWithGC(() => {
            return this.refs.binding.SkipRuntime_closeService();
        });
        if (errorHdl) {
            throw this.refs.handles.deleteHandle(errorHdl);
        }
    }
}
class ValuesImpl {
    constructor(skjson, binding, pointer) {
        this.skjson = skjson;
        this.binding = binding;
        this.pointer = pointer;
        this.toArray = () => {
            return Array.from(this);
        };
        this.skjson = skjson;
        this.binding = binding;
        this.pointer = pointer;
    }
    next() {
        return this.skjson.importOptJSON(this.binding.SkipRuntime_NonEmptyIterator__next(this.pointer));
    }
    getUnique() {
        const value = this.skjson.importOptJSON(this.binding.SkipRuntime_NonEmptyIterator__uniqueValue(this.pointer));
        if (value == null)
            throw new NonUniqueValueException();
        return value;
    }
    [Symbol.iterator]() {
        const cloned_iter = new ValuesImpl(this.skjson, this.binding, this.binding.SkipRuntime_NonEmptyIterator__clone(this.pointer));
        return {
            next() {
                const value = cloned_iter.next();
                return { value, done: value == null };
            },
        };
    }
}
export class ToBinding {
    constructor(binding, runWithGC, getConverter, getError) {
        this.binding = binding;
        this.runWithGC = runWithGC;
        this.getConverter = getConverter;
        this.getError = getError;
        this.stack = new Stack();
        this.handles = new Handles();
    }
    register(v) {
        return this.handles.register(v);
    }
    deleteHandle(id) {
        return this.handles.deleteHandle(id);
    }
    SkipRuntime_getErrorHdl(exn) {
        return this.handles.register(this.getError(exn));
    }
    SkipRuntime_pushContext(context) {
        this.stack.push(context);
    }
    SkipRuntime_popContext() {
        this.stack.pop();
    }
    SkipRuntime_getContext() {
        return this.stack.get();
    }
    // Mapper
    SkipRuntime_Mapper__mapEntry(skmapper, key, values) {
        const skjson = this.getJsonConverter();
        const mapper = this.handles.get(skmapper);
        const result = mapper.mapEntry(skjson.importJSON(key), new ValuesImpl(skjson, this.binding, values));
        return skjson.exportJSON(Array.from(result));
    }
    SkipRuntime_deleteMapper(mapper) {
        this.handles.deleteHandle(mapper);
    }
    // LazyCompute
    SkipRuntime_LazyCompute__compute(sklazyCompute, self, skkey) {
        const skjson = this.getJsonConverter();
        const lazyCompute = this.handles.get(sklazyCompute);
        const result = lazyCompute.compute(new LazyCollectionImpl(self, this.refs()), skjson.importJSON(skkey));
        return skjson.exportJSON(Array.from(result));
    }
    SkipRuntime_deleteLazyCompute(lazyCompute) {
        this.handles.deleteHandle(lazyCompute);
    }
    // Resource
    SkipRuntime_Resource__instantiate(skresource, skcollections) {
        const skjson = this.getJsonConverter();
        const resource = this.handles.get(skresource);
        const collections = {};
        const keysIds = skjson.importJSON(skcollections);
        const refs = this.refs();
        for (const [key, name] of Object.entries(keysIds)) {
            collections[key] = new EagerCollectionImpl(name, refs);
        }
        const collection = resource.instantiate(collections, new ContextImpl(refs));
        return collection.collection;
    }
    SkipRuntime_deleteResource(resource) {
        this.handles.deleteHandle(resource);
    }
    // ResourceBuilder
    SkipRuntime_ResourceBuilder__build(skbuilder, skparams) {
        const skjson = this.getJsonConverter();
        const builder = this.handles.get(skbuilder);
        const resource = builder.build(skjson.importJSON(skparams));
        return this.binding.SkipRuntime_createResource(this.handles.register(resource));
    }
    SkipRuntime_deleteResourceBuilder(builder) {
        this.handles.deleteHandle(builder);
    }
    // Service
    SkipRuntime_Service__createGraph(skservice, skcollections) {
        const skjson = this.getJsonConverter();
        const service = this.handles.get(skservice);
        const collections = {};
        const keysIds = skjson.importJSON(skcollections);
        const refs = this.refs();
        for (const [key, name] of Object.entries(keysIds)) {
            collections[key] = new EagerCollectionImpl(name, refs);
        }
        const result = service.createGraph(collections, new ContextImpl(refs));
        const collectionsNames = {};
        for (const [name, collection] of Object.entries(result)) {
            collectionsNames[name] = collection.collection;
        }
        return skjson.exportJSON(collectionsNames);
    }
    SkipRuntime_deleteService(service) {
        this.handles.deleteHandle(service);
    }
    // Notifier
    SkipRuntime_Notifier__subscribed(sknotifier) {
        const notifier = this.handles.get(sknotifier);
        notifier.subscribed();
    }
    SkipRuntime_Notifier__notify(sknotifier, skvalues, watermark, isUpdates) {
        const skjson = this.getJsonConverter();
        const notifier = this.handles.get(sknotifier);
        const values = skjson.importJSON(skvalues, true);
        const isInitial = isUpdates ? false : true;
        notifier.notify({
            values,
            watermark,
            isInitial,
        });
    }
    SkipRuntime_Notifier__close(sknotifier) {
        const notifier = this.handles.get(sknotifier);
        notifier.close();
    }
    SkipRuntime_deleteNotifier(notifier) {
        this.handles.deleteHandle(notifier);
    }
    // Reducer
    SkipRuntime_Reducer__add(skreducer, skacc, skvalue) {
        const skjson = this.getJsonConverter();
        const reducer = this.handles.get(skreducer);
        return skjson.exportJSON(reducer.add(skacc ? skjson.importJSON(skacc) : null, skjson.importJSON(skvalue)));
    }
    SkipRuntime_Reducer__remove(skreducer, skacc, skvalue) {
        const skjson = this.getJsonConverter();
        const reducer = this.handles.get(skreducer);
        return skjson.exportJSON(reducer.remove(skjson.importJSON(skacc), skjson.importJSON(skvalue)));
    }
    SkipRuntime_deleteReducer(reducer) {
        this.handles.deleteHandle(reducer);
    }
    // ExternalService
    SkipRuntime_ExternalService__subscribe(sksupplier, writerId, resource, skparams) {
        const skjson = this.getJsonConverter();
        const supplier = this.handles.get(sksupplier);
        const writer = new CollectionWriter(writerId, this.refs());
        const params = skjson.importJSON(skparams, true);
        supplier.subscribe(resource, params, {
            update: writer.update.bind(writer),
            error: writer.error.bind(writer),
            loading: writer.loading.bind(writer),
        });
    }
    SkipRuntime_ExternalService__unsubscribe(sksupplier, resource, skparams) {
        const skjson = this.getJsonConverter();
        const supplier = this.handles.get(sksupplier);
        const params = skjson.importJSON(skparams, true);
        supplier.unsubscribe(resource, params);
    }
    SkipRuntime_ExternalService__shutdown(sksupplier) {
        const supplier = this.handles.get(sksupplier);
        supplier.shutdown();
    }
    SkipRuntime_deleteExternalService(supplier) {
        this.handles.deleteHandle(supplier);
    }
    // Checker
    SkipRuntime_Checker__check(skchecker, request) {
        const checker = this.handles.get(skchecker);
        checker.check(request);
    }
    SkipRuntime_deleteChecker(checker) {
        this.handles.deleteHandle(checker);
    }
    initService(service) {
        const refs = this.refs();
        const errorHdl = refs.runWithGC(() => {
            const skExternalServices = refs.binding.SkipRuntime_ExternalServiceMap__create();
            if (service.externalServices) {
                for (const [name, remote] of Object.entries(service.externalServices)) {
                    const skremote = refs.binding.SkipRuntime_createExternalService(refs.handles.register(remote));
                    refs.binding.SkipRuntime_ExternalServiceMap__add(skExternalServices, name, skremote);
                }
            }
            const skresources = refs.binding.SkipRuntime_ResourceBuilderMap__create();
            for (const [name, builder] of Object.entries(service.resources)) {
                const skbuilder = refs.binding.SkipRuntime_createResourceBuilder(refs.handles.register(new ResourceBuilder(builder)));
                refs.binding.SkipRuntime_ResourceBuilderMap__add(skresources, name, skbuilder);
            }
            const skservice = refs.binding.SkipRuntime_createService(refs.handles.register(service), refs.skjson.exportJSON(service.initialData ?? {}), skresources, skExternalServices);
            return refs.binding.SkipRuntime_initService(skservice);
        });
        if (errorHdl)
            throw refs.handles.deleteHandle(errorHdl);
        return new ServiceInstance(refs);
    }
    //
    getJsonConverter() {
        if (this.skjson == undefined) {
            this.skjson = this.getConverter();
        }
        return this.skjson;
    }
    needGC() {
        return this.SkipRuntime_getContext() == null;
    }
    refs() {
        return new Refs(this.binding, this.getConverter(), this.handles, this.needGC.bind(this), this.runWithGC);
    }
}
//# sourceMappingURL=index.js.map