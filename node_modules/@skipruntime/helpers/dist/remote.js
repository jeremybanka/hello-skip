// TODO: Remove once global `EventSource` makes it out of experimental
// in nodejs LTS.
import EventSource from "eventsource";
/**
 * An external Skip reactive service.
 *
 * `SkipExternalService` provides an implementation of `ExternalService` for an external Skip service.
 */
export class SkipExternalService {
    /**
     * @param url - URL to use for the service's streaming interface.
     * @param control_url - URL to use for the service's control interface.
     */
    constructor(url, control_url) {
        this.url = url;
        this.control_url = control_url;
        this.resources = new Map();
    }
    /**
     * Constructor accepting an `Entrypoint`.
     *
     * @param entrypoint - The entry point for the external Skip service.
     * @returns An `ExternalService` to interact with the service running at `entrypoint`.
     */
    // TODO: Support Skip external services going through a gateway.
    static direct(entrypoint) {
        let url = `http://${entrypoint.host}:${entrypoint.streaming_port.toString()}`;
        let control_url = `http://${entrypoint.host}:${entrypoint.control_port.toString()}`;
        if (entrypoint.secured) {
            url = `https://${entrypoint.host}:${entrypoint.streaming_port.toString()}`;
            control_url = `https://${entrypoint.host}:${entrypoint.control_port.toString()}`;
        }
        return new SkipExternalService(url, control_url);
    }
    subscribe(resource, params, callbacks) {
        // TODO Manage Status
        fetch(`${this.control_url}/v1/streams`, {
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            },
            body: JSON.stringify({
                resource,
                params,
            }),
        })
            .then((resp) => resp.text())
            .then((uuid) => {
            const evSource = new EventSource(`${this.url}/v1/streams/${uuid}`);
            evSource.addEventListener("init", (e) => {
                const updates = JSON.parse(e.data);
                callbacks.update(updates, true);
            });
            evSource.addEventListener("update", (e) => {
                const updates = JSON.parse(e.data);
                callbacks.update(updates, false);
            });
            evSource.onerror = (e) => {
                console.log(e);
            };
            this.resources.set(this.toId(resource, params), evSource);
        })
            .catch((e) => {
            console.log(e);
        });
    }
    unsubscribe(resource, params) {
        const closable = this.resources.get(this.toId(resource, params));
        if (closable)
            closable.close();
    }
    shutdown() {
        for (const res of this.resources.values()) {
            res.close();
        }
    }
    toId(resource, params) {
        if (typeof params == "object") {
            const strparams = Object.entries(params)
                .map(([key, value]) => `${key}:${btoa(JSON.stringify(value))}`)
                .sort();
            return `${resource}[${strparams.join(",")}]`;
        }
        else
            return `${resource}[${btoa(JSON.stringify(params))}]`;
    }
}
//# sourceMappingURL=remote.js.map