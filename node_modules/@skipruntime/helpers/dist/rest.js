import { NonUniqueValueException } from "@skipruntime/api";
function toHttp(entrypoint) {
    if (entrypoint.secured)
        return `https://${entrypoint.host}:${entrypoint.control_port}`;
    return `http://${entrypoint.host}:${entrypoint.control_port}`;
}
/**
 * Perform an HTTP fetch where input and output data is `Json`.
 *
 * @typeParam V - Type response is *assumed* to have.
 * @param url - URL from which to fetch.
 * @param method - HTTP method of request.
 * @param options - Optional parameters.
 * @param options.headers - Additional headers to add to request.
 * @param options.body - Data to convert to JSON and send in request body.
 * @param options.timeout - Timeout for request, in milliseconds. Defaults to 1000ms.
 * @returns Response parsed as JSON, and headers.
 */
export async function fetchJSON(url, method = "GET", options = {
    headers: {},
    timeout: 1000,
}) {
    const body = options.body ? JSON.stringify(options.body) : undefined;
    const response = await fetch(url, {
        method,
        body,
        headers: {
            "Content-Type": "application/json",
            Accept: "application/json",
            ...options.headers,
        },
        signal: AbortSignal.timeout(1000),
    });
    if (!response.ok) {
        throw new Error(`${response.status}: ${response.statusText}`);
    }
    const responseText = await response.text();
    const responseJSON = responseText.length > 0 && responseText != response.statusText
        ? JSON.parse(responseText)
        : null;
    return [responseJSON, response.headers];
}
/**
 * Wrapper providing a method-call interface to the Skip service HTTP APIs.
 *
 * Skip services, as started by `runService`, support an HTTP interface for reading from resources and writing to input collections.
 * `SkipServiceBroker` provides a method-call interface to the backing HTTP interface.
 */
export class SkipServiceBroker {
    /**
     * Construct a broker for a Skip service at the given entry point.
     *
     * @param entrypoint - Entry point of backing service.
     * @returns Method-call broker to service.
     */
    constructor(entrypoint = {
        host: "localhost",
        streaming_port: 8080,
        control_port: 8081,
    }) {
        this.entrypoint = toHttp(entrypoint);
    }
    /**
     * Read the entire contents of a resource.
     *
     * @typeParam K - Type of keys.
     * @typeParam V - Type of values.
     * @param resource - Name of resource, must be a key of the `resources` field of the `SkipService` running at `entrypoint`.
     * @param params - Resource instance parameters.
     * @returns All entries in resource.
     */
    async getAll(resource, params) {
        const [data, _headers] = await fetchJSON(`${this.entrypoint}/v1/snapshot/${resource}`, "POST", { body: params });
        return data ?? [];
    }
    /**
     * Read the values a resource associates with a single key.
     *
     * @typeParam K - Type of keys.
     * @typeParam V - Type of values.
     * @param resource - Name of resource, must be a key of the `resources` field of the `SkipService` running at `entrypoint`.
     * @param params - Resource instance parameters.
     * @param key - Key to read.
     * @returns The values associated to the key.
     */
    async getArray(resource, params, key) {
        const [data, _headers] = await fetchJSON(`${this.entrypoint}/v1/snapshot/${resource}/lookup`, "POST", { body: { key, params } });
        return data ?? [];
    }
    /**
     * Read the single value a resource associates with a key.
     *
     * @typeParam K - Type of keys.
     * @typeParam V - Type of values.
     * @param resource - Name of resource, must be a key of the `resources` field of the `SkipService` running at `entrypoint`.
     * @param params - Resource instance parameters.
     * @param key - Key to read.
     * @returns The value associated to the key.
     * @throws `NonUniqueValueException` when the key is associated to either zero or multiple values.
     */
    async getUnique(resource, params, key) {
        return this.getArray(resource, params, key).then((values) => {
            if (values.length !== 1 || values[0] === undefined)
                throw new NonUniqueValueException();
            return values[0];
        });
    }
    /**
     * Write the values for a single key in a collection.
     *
     * @typeParam K - Type of keys.
     * @typeParam V - Type of values.
     * @param collection - Name of the input collection to update, must be a key of the `Inputs` type parameter of the `SkipService` running at `entrypoint`.
     * @param key - Key of entry to write.
     * @param values - Values of entry to write.
     * @returns {void}
     */
    async put(collection, key, values) {
        return await this.patch(collection, [[key, values]]);
    }
    /**
     * Write multiple entries to a collection.
     *
     * @typeParam K - Type of keys.
     * @typeParam V - Type of values.
     * @param collection - Name of the input collection to update, must be a key of the `Inputs` type parameter of the `SkipService` running at `entrypoint`.
     * @param entries - Entries to write.
     * @returns {void}
     */
    async patch(collection, entries) {
        await fetchJSON(`${this.entrypoint}/v1/inputs/${collection}`, "PATCH", {
            body: entries,
        });
    }
    /**
     * Remove all values associated with a key in a collection.
     *
     * @typeParam K - Type of keys.
     * @param collection - Name of the input collection to update, must be a key of the `Inputs` type parameter of the `SkipService` running at `entrypoint`.
     * @param key - Key of entry to delete.
     * @returns {void}
     */
    async deleteKey(collection, key) {
        return await this.patch(collection, [[key, []]]);
    }
    /**
     * Create a resource instance UUID.
     *
     * @typeParam K - Type of keys.
     * @typeParam V - Type of values.
     * @param resource - Name of resource, must be a key of the `resources` field of the `SkipService` running at `entrypoint`.
     * @param params - Resource instance parameters.
     * @returns UUID that can be used to subscribe to updates to resource instance.
     */
    async getStreamUUID(resource, params = {}) {
        return fetch(`${this.entrypoint}/v1/streams/${resource}`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(params),
        }).then((res) => res.text());
    }
    /**
     * Destroy a resource instance.
     *
     * Under normal circumstances, resource instances are deleted automatically after some period of inactivity; this method enables immediately deleting live streams under exceptional circumstances.
     *
     * @param uuid - Resource instance UUID.
     * @returns {void}
     */
    async deleteUUID(uuid) {
        await fetchJSON(`${this.entrypoint}/v1/streams/${uuid}`, "DELETE");
    }
}
//# sourceMappingURL=rest.js.map