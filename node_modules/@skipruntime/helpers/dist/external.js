import { fetchJSON } from "./rest.js";
/**
 * A generic external service providing external resources.
 *
 * `GenericExternalService` provides an implementation of `ExternalService` for external resources by lifting the `open` and `close` operations from `ExternalResource` to the `subscribe` and `unsubscribe` operations required by `ExternalService`.
 */
export class GenericExternalService {
    /**
     * @param resources - Association of resource names to `ExternalResource`s.
     */
    constructor(resources) {
        this.resources = resources;
    }
    subscribe(resourceName, params, callbacks) {
        const resource = this.resources[resourceName];
        if (!resource) {
            throw new Error(`Unkonwn resource named '${resourceName}'`);
        }
        resource.open(params, callbacks);
    }
    unsubscribe(resourceName, params) {
        const resource = this.resources[resourceName];
        if (!resource) {
            throw new Error(`Unkonwn resource named '${resourceName}'`);
        }
        resource.close(params);
    }
    shutdown() {
        return;
    }
}
export class TimerResource {
    constructor() {
        this.intervals = new Map();
    }
    open(params, callbacks) {
        const time = new Date().getTime();
        const values = [];
        for (const name of Object.keys(params)) {
            values.push([name, [time]]);
        }
        callbacks.update(values, true);
        const id = toId(params);
        const intervals = {};
        for (const [name, duration] of Object.entries(params)) {
            const ms = Number(duration);
            if (ms > 0) {
                intervals[name] = setInterval(() => {
                    const newvalue = [name, [new Date().getTime()]];
                    callbacks.update([newvalue], true);
                }, ms);
            }
        }
        this.intervals.set(id, intervals);
    }
    close(params) {
        const intervals = this.intervals.get(toId(params));
        if (intervals != null) {
            for (const interval of Object.values(intervals)) {
                clearInterval(interval);
            }
        }
    }
}
function defaultParamEncoder(params) {
    if (typeof params == "object") {
        const queryParams = {};
        for (const [key, value] of Object.entries(params)) {
            if (typeof value == "object")
                queryParams[key] = JSON.stringify(value);
            else
                queryParams[key] = value.toString();
        }
        return new URLSearchParams(queryParams).toString();
    }
    else
        return `params=${JSON.stringify(params)}`;
}
/**
 * An external resource that is refreshed at some polling interval.
 *
 * @typeParam S - Type of data received from external resource.
 * @typeParam K - Type of keys.
 * @typeParam V - Type of values.
 */
export class Polled {
    /**
     * @param url - HTTP endpoint of external resource to poll.
     * @param duration - Refresh interval, in milliseconds.
     * @param conv - Function to convert data of type `S` received from external resource to `key`-`value` entries.
     * @param encodeParams - Function to use to encode params of type `Json` for external resource request.
     */
    constructor(url, duration, conv, encodeParams = defaultParamEncoder) {
        this.url = url;
        this.duration = duration;
        this.conv = conv;
        this.encodeParams = encodeParams;
        this.intervals = new Map();
    }
    open(params, callbacks) {
        this.close(params);
        const url = `${this.url}?${this.encodeParams(params)}`;
        const call = () => {
            callbacks.loading();
            fetchJSON(url, "GET", {})
                .then((r) => {
                callbacks.update(this.conv(r[0]), true);
            })
                .catch((e) => {
                callbacks.error(e instanceof Error ? e.message : JSON.stringify(e));
                console.error(e);
            });
        };
        call();
        this.intervals.set(toId(params), setInterval(call, this.duration));
    }
    close(params) {
        const interval = this.intervals.get(toId(params));
        if (interval) {
            clearInterval(interval);
        }
    }
}
function toId(params) {
    if (typeof params == "object") {
        const strparams = Object.entries(params)
            .map(([key, value]) => `${key}:${btoa(JSON.stringify(value))}`)
            .sort();
        return `[${strparams.join(",")}]`;
    }
    else
        return btoa(JSON.stringify(params));
}
//# sourceMappingURL=external.js.map