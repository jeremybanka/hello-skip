import type { Json, Entry } from "@skipruntime/api";
/**
 * An entry point of a Skip reactive service.
 *
 * URLs for the service's control and streaming APIs can be constructed from an `Entrypoint`.
 */
export type Entrypoint = {
    /**
     * Hostname of the service.
     */
    host: string;
    /**
     * Port to use for the service's streaming interface.
     */
    streaming_port: number;
    /**
     * Port to use for the service's control interface.
     */
    control_port: number;
    /**
     * Flag that when set indicates that https should be used instead of http.
     */
    secured?: boolean;
};
/**
 * Perform an HTTP fetch where input and output data is `Json`.
 *
 * @typeParam V - Type response is *assumed* to have.
 * @param url - URL from which to fetch.
 * @param method - HTTP method of request.
 * @param options - Optional parameters.
 * @param options.headers - Additional headers to add to request.
 * @param options.body - Data to convert to JSON and send in request body.
 * @param options.timeout - Timeout for request, in milliseconds. Defaults to 1000ms.
 * @returns Response parsed as JSON, and headers.
 */
export declare function fetchJSON<V extends Json>(url: string, method?: "POST" | "GET" | "PUT" | "PATCH" | "HEAD" | "DELETE", options?: {
    headers?: {
        [header: string]: string;
    };
    body?: Json;
    timeout?: number;
}): Promise<[V | null, Headers]>;
/**
 * Wrapper providing a method-call interface to the Skip service HTTP APIs.
 *
 * Skip services, as started by `runService`, support an HTTP interface for reading from resources and writing to input collections.
 * `SkipServiceBroker` provides a method-call interface to the backing HTTP interface.
 */
export declare class SkipServiceBroker {
    private readonly entrypoint;
    /**
     * Construct a broker for a Skip service at the given entry point.
     *
     * @param entrypoint - Entry point of backing service.
     * @returns Method-call broker to service.
     */
    constructor(entrypoint?: Entrypoint);
    /**
     * Read the entire contents of a resource.
     *
     * @typeParam K - Type of keys.
     * @typeParam V - Type of values.
     * @param resource - Name of resource, must be a key of the `resources` field of the `SkipService` running at `entrypoint`.
     * @param params - Resource instance parameters.
     * @returns All entries in resource.
     */
    getAll<K extends Json, V extends Json>(resource: string, params: Json): Promise<Entry<K, V>[]>;
    /**
     * Read the values a resource associates with a single key.
     *
     * @typeParam K - Type of keys.
     * @typeParam V - Type of values.
     * @param resource - Name of resource, must be a key of the `resources` field of the `SkipService` running at `entrypoint`.
     * @param params - Resource instance parameters.
     * @param key - Key to read.
     * @returns The values associated to the key.
     */
    getArray<K extends Json, V extends Json>(resource: string, params: Json, key: K): Promise<V[]>;
    /**
     * Read the single value a resource associates with a key.
     *
     * @typeParam K - Type of keys.
     * @typeParam V - Type of values.
     * @param resource - Name of resource, must be a key of the `resources` field of the `SkipService` running at `entrypoint`.
     * @param params - Resource instance parameters.
     * @param key - Key to read.
     * @returns The value associated to the key.
     * @throws `NonUniqueValueException` when the key is associated to either zero or multiple values.
     */
    getUnique<K extends Json, V extends Json>(resource: string, params: Json, key: K): Promise<V>;
    /**
     * Write the values for a single key in a collection.
     *
     * @typeParam K - Type of keys.
     * @typeParam V - Type of values.
     * @param collection - Name of the input collection to update, must be a key of the `Inputs` type parameter of the `SkipService` running at `entrypoint`.
     * @param key - Key of entry to write.
     * @param values - Values of entry to write.
     * @returns {void}
     */
    put<K extends Json, V extends Json>(collection: string, key: K, values: V[]): Promise<void>;
    /**
     * Write multiple entries to a collection.
     *
     * @typeParam K - Type of keys.
     * @typeParam V - Type of values.
     * @param collection - Name of the input collection to update, must be a key of the `Inputs` type parameter of the `SkipService` running at `entrypoint`.
     * @param entries - Entries to write.
     * @returns {void}
     */
    patch<K extends Json, V extends Json>(collection: string, entries: Entry<K, V>[]): Promise<void>;
    /**
     * Remove all values associated with a key in a collection.
     *
     * @typeParam K - Type of keys.
     * @param collection - Name of the input collection to update, must be a key of the `Inputs` type parameter of the `SkipService` running at `entrypoint`.
     * @param key - Key of entry to delete.
     * @returns {void}
     */
    deleteKey<K extends Json>(collection: string, key: K): Promise<void>;
    /**
     * Create a resource instance UUID.
     *
     * @typeParam K - Type of keys.
     * @typeParam V - Type of values.
     * @param resource - Name of resource, must be a key of the `resources` field of the `SkipService` running at `entrypoint`.
     * @param params - Resource instance parameters.
     * @returns UUID that can be used to subscribe to updates to resource instance.
     */
    getStreamUUID(resource: string, params?: Json): Promise<string>;
    /**
     * Destroy a resource instance.
     *
     * Under normal circumstances, resource instances are deleted automatically after some period of inactivity; this method enables immediately deleting live streams under exceptional circumstances.
     *
     * @param uuid - Resource instance UUID.
     * @returns {void}
     */
    deleteUUID(uuid: string): Promise<void>;
}
//# sourceMappingURL=rest.d.ts.map