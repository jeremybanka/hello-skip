import * as Internal from "./internal.js";
import { Type } from "./binding.js";
export const sk_isObjectProxy = Symbol();
export const sk_managed = Symbol.for("Skip.managed");
export class Frozen {
    constructor() {
        this.freeze();
    }
}
export function sk_freeze(x) {
    return Object.defineProperty(x, sk_managed, {
        enumerable: false,
        writable: false,
        value: true,
    });
}
export function isSkManaged(x) {
    return sk_managed in x && x[sk_managed] === true;
}
export class SkManaged extends Frozen {
    freeze() {
        sk_freeze(this);
    }
}
export function checkOrCloneParam(value) {
    if (typeof value == "string" ||
        typeof value == "number" ||
        typeof value == "boolean")
        return value;
    if (typeof value == "object") {
        if (value === null)
            return value;
        if (isObjectProxy(value))
            return value.clone();
        if (isSkManaged(value))
            return value;
        throw new Error("Invalid object: must be deep-frozen.");
    }
    throw new Error(`'${typeof value}' cannot be deep-frozen.`);
}
/**
 * _Deep-freeze_ an object, making it dependency-safe.
 *
 * This function is similar to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze | Object.freeze()} but freezes the object and deep-freezes all its properties, recursively.
 * The object is then not only _immutable_ but also _constant_.
 * Note that as a result all objects reachable from the parameter will be frozen and no longer mutable or extensible, even from other references.
 *
 * The argument object and all its properties, recursively, must not already be frozen by `Object.freeze` (or else `deepFreeze` cannot mark them deep-frozen).
 * Undefined, function (and hence class) values cannot be deep-frozen.
 *
 * The primary use for this function is to satisfy the requirement that all parameters to Skip `Mapper` or `Reducer` constructors must be dependency-safe: objects that have not been constructed by Skip can be passed to `deepFreeze()` before passing them to a `Mapper` or `Reducer` constructor.
 *
 * @typeParam T - Type of value to deep-freeze.
 * @param value - The object to deep-freeze.
 * @returns The same object that was passed in.
 */
export function deepFreeze(value) {
    if (typeof value == "bigint" ||
        typeof value == "boolean" ||
        typeof value == "number" ||
        typeof value == "string" ||
        typeof value == "symbol") {
        return value;
    }
    else if (typeof value == "object") {
        if (value === null) {
            return value;
        }
        else if (isSkManaged(value)) {
            return value;
        }
        else if (Object.isFrozen(value)) {
            throw new Error(`Cannot deep-freeze an Object.frozen value.`);
        }
        else if (Array.isArray(value)) {
            for (const elt of value) {
                deepFreeze(elt);
            }
            return Object.freeze(sk_freeze(value));
        }
        else {
            for (const val of Object.values(value)) {
                deepFreeze(val);
            }
            return Object.freeze(sk_freeze(value));
        }
    }
    else {
        // typeof value == "function" || typeof value == "undefined"
        throw new Error(`'${typeof value}' values cannot be deep-frozen.`);
    }
}
export function isObjectProxy(x) {
    return sk_isObjectProxy in x && x[sk_isObjectProxy];
}
export const reactiveObject = {
    get(hdl, prop, self) {
        if (prop === sk_isObjectProxy)
            return true;
        if (prop === sk_managed)
            return true;
        if (prop === "__pointer")
            return hdl.pointer;
        if (prop === "clone")
            return () => clone(self);
        if (typeof prop === "symbol")
            return undefined;
        const fields = hdl.objectFields();
        if (prop === "toJSON")
            return () => {
                return Object.fromEntries(Array.from(fields).map(([k, ptr]) => [k, getFieldAt(hdl, ptr)]));
            };
        if (prop === "keys")
            return fields.keys();
        if (prop === "toString")
            return () => JSON.stringify(self);
        const idx = fields.get(prop);
        if (idx === undefined)
            return undefined;
        return getFieldAt(hdl, idx);
    },
    set(_hdl, _prop, _value) {
        throw new Error("Reactive object cannot be modified.");
    },
    has(hdl, prop) {
        if (prop === sk_isObjectProxy)
            return true;
        if (prop === sk_managed)
            return true;
        if (prop === "__pointer")
            return true;
        if (prop === "clone")
            return true;
        if (prop === "keys")
            return true;
        if (prop === "toJSON")
            return true;
        if (prop === "toString")
            return true;
        if (typeof prop === "symbol")
            return false;
        const fields = hdl.objectFields();
        return fields.has(prop);
    },
    ownKeys(hdl) {
        return Array.from(hdl.objectFields().keys());
    },
    getOwnPropertyDescriptor(hdl, prop) {
        if (typeof prop === "symbol")
            return undefined;
        const fields = hdl.objectFields();
        const idx = fields.get(prop);
        if (idx === undefined)
            return undefined;
        const value = getFieldAt(hdl, idx);
        return {
            configurable: true,
            enumerable: true,
            writable: false,
            value,
        };
    },
};
export function clone(value) {
    if (value !== null && typeof value === "object") {
        if (Array.isArray(value)) {
            return value.map(clone);
        }
        else if (isObjectProxy(value)) {
            return Object.fromEntries(Array.from(value.keys).map((k) => [k, clone(value[k])]));
        }
        else {
            return Object.fromEntries(Object.entries(value).map(([k, v]) => [k, clone(v)]));
        }
    }
    else {
        return value;
    }
}
function interpretPointer(hdl, pointer) {
    if (pointer === null)
        return null;
    const type = hdl.binding.SKIP_SKJSON_typeOf(pointer);
    switch (type) {
        case Type.Null:
            return null;
        case Type.Int:
        case Type.Float:
            return hdl.binding.SKIP_SKJSON_asNumber(pointer);
        case Type.Boolean:
            return hdl.binding.SKIP_SKJSON_asBoolean(pointer);
        case Type.String:
            return hdl.binding.SKIP_SKJSON_asString(pointer);
        case Type.Array: {
            const aPtr = hdl.binding.SKIP_SKJSON_asArray(pointer);
            const length = hdl.binding.SKIP_SKJSON_arraySize(aPtr);
            const array = Array.from({ length }, (_, idx) => interpretPointer(hdl, hdl.binding.SKIP_SKJSON_at(aPtr, idx)));
            return sk_freeze(array);
        }
        case Type.Object: {
            const oPtr = hdl.binding.SKIP_SKJSON_asObject(pointer);
            return new Proxy(hdl.derive(oPtr), reactiveObject);
        }
        case Type.Undefined:
        default:
            return undefined;
    }
}
function getFieldAt(hdl, idx) {
    return interpretPointer(hdl, hdl.binding.SKIP_SKJSON_get(hdl.pointer, idx));
}
class ObjectHandle {
    constructor(binding, pointer) {
        this.pointer = pointer;
        this.binding = binding;
    }
    objectFields() {
        if (!this.fields) {
            this.fields = new Map();
            const size = this.binding.SKIP_SKJSON_objectSize(this.pointer);
            for (let i = 0; i < size; i++) {
                const field = this.binding.SKIP_SKJSON_fieldAt(this.pointer, i);
                if (!field)
                    break;
                this.fields.set(field, i);
            }
        }
        return this.fields;
    }
    derive(pointer) {
        return new ObjectHandle(this.binding, pointer);
    }
}
export function exportJSON(binding, value) {
    if (value === null || value === undefined) {
        return binding.SKIP_SKJSON_createCJNull();
    }
    else if (typeof value == "number") {
        if (value === Math.trunc(value)) {
            return binding.SKIP_SKJSON_createCJInt(value);
        }
        else {
            return binding.SKIP_SKJSON_createCJFloat(value);
        }
    }
    else if (typeof value == "boolean") {
        return binding.SKIP_SKJSON_createCJBool(value);
    }
    else if (typeof value == "string") {
        return binding.SKIP_SKJSON_createCJString(value);
    }
    else if (Array.isArray(value)) {
        const arr = binding.SKIP_SKJSON_startCJArray();
        value.forEach((v) => {
            binding.SKIP_SKJSON_addToCJArray(arr, exportJSON(binding, v));
        });
        return binding.SKIP_SKJSON_endCJArray(arr);
    }
    else if (typeof value == "object") {
        if (isObjectProxy(value)) {
            return value.__pointer;
        }
        else {
            const obj = binding.SKIP_SKJSON_startCJObject();
            Object.entries(value).forEach(([key, val]) => {
                binding.SKIP_SKJSON_addToCJObject(obj, key, exportJSON(binding, val));
            });
            return binding.SKIP_SKJSON_endCJObject(obj);
        }
    }
    else {
        throw new Error(`'${typeof value}' cannot be exported to wasm.`);
    }
}
export function importJSON(binding, pointer, copy) {
    const value = interpretPointer(new ObjectHandle(binding, pointer), pointer);
    return copy && value !== null ? clone(value) : value;
}
export class JsonConverterImpl {
    constructor(binding) {
        this.binding = binding;
    }
    importJSON(value, copy) {
        return importJSON(this.binding, value, copy);
    }
    exportJSON(v) {
        return exportJSON(this.binding, v);
    }
    clone(v) {
        return clone(v);
    }
    is(v, type) {
        return this.binding.SKIP_SKJSON_typeOf(v) == type;
    }
    importOptJSON(value, copy) {
        if (value === null) {
            return null;
        }
        return this.importJSON(value, copy);
    }
}
export function buildJsonConverter(binding) {
    return new JsonConverterImpl(binding);
}
//# sourceMappingURL=index.js.map