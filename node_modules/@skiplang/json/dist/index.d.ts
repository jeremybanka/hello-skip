import * as Internal from "./internal.js";
import { Type, type Binding } from "./binding.js";
import type { Pointer, Nullable } from "@skiplang/std";
export type { Pointer, Nullable, Binding };
export type { Type };
export declare const sk_isObjectProxy: unique symbol;
export declare const sk_managed: unique symbol;
/**
 * Values that are either unmodifiable or tracked by the Skip Runtime.
 *
 * A `Managed` value is either managed by the Skip Runtime, in which case its modifications are carefully tracked by the reactive computation system, or it is deep-frozen, meaning that it cannot be modified and neither can its sub-objects, recursively.
 * See `deepFreeze` to make an object `Managed`.
 *
 * `Managed` values are important because they can be used in code that will be executed by the reactive computation system without introducing the possibility of stale or unreproducible results.
 */
export type Managed = {
    /**
     * @ignore
     * @hidden
     */
    [sk_managed]: true;
};
export declare abstract class Frozen implements Managed {
    [sk_managed]: true;
    constructor();
    protected abstract freeze(): void;
}
export declare function sk_freeze<T extends object>(x: T): T & Managed;
export declare function isSkManaged(x: any): x is Managed;
export declare abstract class SkManaged extends Frozen {
    protected freeze(): void;
}
/**
 * A `DepSafe` value is _dependency-safe_ and can be used safely in reactive computations.
 *
 * A value can be safely used as a dependency of a reactive computation if it is:
 * 1. a primitive JavaScript value (boolean, number, string, etc.)
 * 2. managed by the Skip runtime, which will correctly track dependencies, or
 * 3. a deep-frozen and therefore constant JavaScript object.
 *
 * Values used in reactive computations must be dependency-safe so that reactive computations can be reevaluated as needed with consistent semantics.
 *
 * All objects/values that come _out_ of the Skip runtime are dependency-safe.
 * Non-Skip objects can be made dependency-safe by passing them to `deepFreeze`, which recursively freezes their fields and returns a constant `Managed` object.
 */
export type DepSafe = null | boolean | number | bigint | string | symbol | Managed;
export declare function checkOrCloneParam<T>(value: T): T;
/**
 * _Deep-freeze_ an object, making it dependency-safe.
 *
 * This function is similar to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze | Object.freeze()} but freezes the object and deep-freezes all its properties, recursively.
 * The object is then not only _immutable_ but also _constant_.
 * Note that as a result all objects reachable from the parameter will be frozen and no longer mutable or extensible, even from other references.
 *
 * The argument object and all its properties, recursively, must not already be frozen by `Object.freeze` (or else `deepFreeze` cannot mark them deep-frozen).
 * Undefined, function (and hence class) values cannot be deep-frozen.
 *
 * The primary use for this function is to satisfy the requirement that all parameters to Skip `Mapper` or `Reducer` constructors must be dependency-safe: objects that have not been constructed by Skip can be passed to `deepFreeze()` before passing them to a `Mapper` or `Reducer` constructor.
 *
 * @typeParam T - Type of value to deep-freeze.
 * @param value - The object to deep-freeze.
 * @returns The same object that was passed in.
 */
export declare function deepFreeze<T>(value: T): T & DepSafe;
/**
 * JSON-serializable values.
 *
 * The `Json` type describes JSON-serializable values and serves as an upper bound on keys and values in the Skip Runtime, ensuring that they can be serialized and managed by the reactive computation engine.
 */
export type Json = number | boolean | string | (Json | null)[] | JsonObject;
/**
 * Objects containing `Json` values.
 */
export type JsonObject = {
    [key: string]: Json | null;
};
export type Exportable = Json | null | undefined | ObjectProxy<{
    [k: string]: Exportable;
}> | (readonly Exportable[] & Managed);
export type ObjectProxy<Base extends {
    [k: string]: Exportable;
}> = {
    [sk_isObjectProxy]: true;
    [sk_managed]: true;
    __pointer: Pointer<Internal.CJSON>;
    clone: () => ObjectProxy<Base>;
    toJSON: () => Base;
    keys: IterableIterator<keyof Base>;
} & Base;
export declare function isObjectProxy(x: any): x is ObjectProxy<{
    [k: string]: Exportable;
}>;
export declare const reactiveObject: {
    get<Base extends {
        [k: string]: Exportable;
    }>(hdl: ObjectHandle<Internal.CJObject>, prop: string | symbol, self: ObjectProxy<Base>): any;
    set(_hdl: ObjectHandle<Internal.CJObject>, _prop: string | symbol, _value: any): never;
    has(hdl: ObjectHandle<Internal.CJObject>, prop: string | symbol): boolean;
    ownKeys(hdl: ObjectHandle<Internal.CJObject>): string[];
    getOwnPropertyDescriptor(hdl: ObjectHandle<Internal.CJObject>, prop: string | symbol): {
        configurable: boolean;
        enumerable: boolean;
        writable: boolean;
        value: Exportable;
    } | undefined;
};
export declare function clone<T>(value: T): T;
declare class ObjectHandle<T extends Internal.CJSON> {
    binding: Binding;
    pointer: Pointer<T>;
    fields?: Map<string, number>;
    constructor(binding: Binding, pointer: Pointer<T>);
    objectFields(this: ObjectHandle<Internal.CJObject>): Map<string, number>;
    derive<U extends Internal.CJSON>(pointer: Pointer<U>): ObjectHandle<U>;
}
export declare function exportJSON(binding: Binding, value: Exportable): Pointer<Internal.CJSON>;
export declare function importJSON<T extends Internal.CJSON>(binding: Binding, pointer: Pointer<T>, copy?: boolean): Exportable;
export interface JsonConverter {
    importJSON(value: Pointer<Internal.CJSON>, copy?: boolean): Exportable;
    exportJSON(v: null | undefined): Pointer<Internal.CJNull>;
    exportJSON(v: number): Pointer<Internal.CJFloat | Internal.CJInt>;
    exportJSON(v: boolean): Pointer<Internal.CJBool>;
    exportJSON(v: string): Pointer<Internal.CJString>;
    exportJSON(v: any[]): Pointer<Internal.CJArray>;
    exportJSON(v: JsonObject): Pointer<Internal.CJObject>;
    exportJSON<T extends Internal.CJSON>(v: ObjectProxy<{
        [k: string]: Exportable;
    }> & {
        __pointer: Pointer<T>;
    }): Pointer<T>;
    exportJSON(v: Nullable<Json>): Pointer<Internal.CJSON>;
    importOptJSON(value: Nullable<Pointer<Internal.CJSON>>, copy?: boolean): Exportable;
    is(v: Pointer<Internal.CJSON>, type: Type): boolean;
    clone<T>(v: T): T;
}
export declare class JsonConverterImpl implements JsonConverter {
    private binding;
    constructor(binding: Binding);
    importJSON(value: Pointer<Internal.CJSON>, copy?: boolean): Exportable;
    exportJSON(v: Exportable): Pointer<Internal.CJSON>;
    clone<T>(v: T): T;
    is(v: Pointer<Internal.CJSON>, type: Type): boolean;
    importOptJSON(value: Nullable<Pointer<Internal.CJSON>>, copy?: boolean): Exportable;
}
export declare function buildJsonConverter(binding: Binding): JsonConverter;
//# sourceMappingURL=index.d.ts.map