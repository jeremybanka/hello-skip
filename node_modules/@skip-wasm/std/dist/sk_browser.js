import { MemFS, MemSys } from "./sk_mem_utils.js";
class WrkImpl {
    constructor(worker) {
        this.worker = worker;
        this.postMessage = (message) => {
            this.worker.postMessage(message);
        };
        this.onMessage = (listener) => {
            this.worker.onmessage = listener;
        };
    }
    static fromPath(url, options) {
        return new this(new Worker(url, options));
    }
}
class Env {
    fs() {
        return this.fileSystem;
    }
    sys() {
        return this.system;
    }
    name() {
        return "browser";
    }
    async fetch(url) {
        let fUrl;
        if (url instanceof URL) {
            fUrl = url;
        }
        else {
            fUrl = new URL(url, import.meta.url);
        }
        return fetch(fUrl).then((res) => res.arrayBuffer());
    }
    constructor(environment) {
        this.disableWarnings = false;
        this.throwRuntime = (code) => {
            this.onException();
            if (code != 0) {
                throw new Error(`Error with code: ${code}`);
            }
        };
        this.shared = new Map();
        this.fileSystem = new MemFS();
        this.system = new MemSys();
        this.environment = environment ?? [];
        const global = typeof window == "undefined" ? self : window;
        this.timestamp = () => global.performance.now();
        const decoder = new TextDecoder("utf8");
        this.decodeUTF8 = (utf8) => decoder.decode(utf8);
        const encoder = new TextEncoder(); // always utf-8
        this.encodeUTF8 = (str) => encoder.encode(str);
        this.base64Decode = (base64) => Uint8Array.from(atob(base64), (c) => c.charCodeAt(0));
        this.base64Encode = (toEncode, url = false) => {
            const base64 = btoa(toEncode);
            return url ? base64.replaceAll("+", "-").replaceAll("/", "_") : base64;
        };
        this.storage = () => localStorage;
        this.onException = () => {
            /* default nop hook */
        };
        this.createSocket = (url) => new WebSocket(url);
        this.createWorker = (url, options) => WrkImpl.fromPath(url, options);
        this.createWorkerWrapper = (worker) => new WrkImpl(worker);
        this.crypto = () => crypto;
    }
}
export function environment(environment) {
    return new Env(environment);
}
//# sourceMappingURL=sk_browser.js.map