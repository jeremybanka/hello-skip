export class Wrappable {
}
class UnmanagedMessage extends Error {
}
export class Function {
    constructor(fn, parameters, wrap) {
        this.fn = fn;
        this.parameters = parameters;
        this.wrap = wrap;
    }
    static as(obj) {
        if (!("fn" in obj) || !("parameters" in obj))
            return null;
        const wrap = "wrap" in obj
            ? obj.wrap
            : undefined;
        const fn = new Function(obj.fn, obj.parameters, wrap);
        return fn;
    }
    static isValid(obj) {
        return "fn" in obj && "parameters" in obj;
    }
}
export class Caller {
    constructor(wrapped, fn, parameters, remove = false) {
        this.wrapped = wrapped;
        this.fn = fn;
        this.parameters = parameters;
        this.remove = remove;
    }
    static convert(obj) {
        if (!("wrapped" in obj) ||
            !("fn" in obj) ||
            !("parameters" in obj) ||
            !("remove" in obj))
            return null;
        const fn = new Caller(obj.wrapped, obj.fn, obj.parameters, obj.remove);
        return fn;
    }
    static isValid(obj) {
        return "fn" in obj && "parameters" in obj;
    }
}
export class Return {
    constructor(success, value) {
        this.success = success;
        this.value = value;
    }
    static as(obj) {
        if (!("success" in obj) || !("value" in obj))
            return null;
        return new Return(obj.success, obj.value);
    }
}
export class MessageId {
    constructor(source, id) {
        this.source = source;
        this.id = id;
    }
    static as(obj) {
        if (!("source" in obj) || !("id" in obj))
            return null;
        return new MessageId(obj.source, obj.id);
    }
}
export class Wrapped {
    constructor(wrapped) {
        this.wrapped = wrapped;
    }
    static as(obj) {
        if (!("wrapped" in obj))
            return null;
        return new Wrapped(obj.wrapped);
    }
}
function asKey(messageId) {
    return `${messageId.source}:${messageId.id}`;
}
export class Sender {
    constructor(close, send) {
        this.close = close;
        this.send = send;
    }
}
export class Message {
    constructor(id, payload) {
        this.id = id;
        this.payload = payload;
    }
    static convert(f, obj) {
        if (!("id" in obj && typeof obj.id === "object"))
            return null;
        if (!("payload" in obj && typeof obj.payload === "object"))
            return null;
        const { id, payload } = obj;
        const messageId = MessageId.as(id);
        const messagePayload = f(payload);
        if (!messageId || !messagePayload)
            return null;
        return new Message(messageId, messagePayload);
    }
    static asFunction(obj) {
        return Message.convert((x) => Function.as(x), obj);
    }
    static asCaller(obj) {
        return Message.convert((x) => Caller.convert(x), obj);
    }
    static asReturn(obj) {
        return Message.convert((x) => Return.as(x), obj);
    }
}
let sourcesLastId = 0;
export class PromiseWorker {
    constructor(worker) {
        this.lastId = 0;
        this.worker = worker;
        this.source = ++sourcesLastId;
        this.callbacks = new Map();
        this.subscriptions = new Map();
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        const self = this;
        this.post = (fn) => {
            const messageId = new MessageId(this.source, ++this.lastId);
            const subscribed = new Set();
            const parameters = fn.parameters.map((p) => {
                if (typeof p == "function") {
                    const subscriptionId = new MessageId(this.source, ++this.lastId);
                    // eslint-disable-next-line @typescript-eslint/no-unsafe-call
                    const wfn = (result) => void p.apply(null, result.value);
                    const key = asKey(subscriptionId);
                    this.subscriptions.set(key, wfn);
                    subscribed.add(key);
                    return subscriptionId;
                }
                else {
                    // eslint-disable-next-line @typescript-eslint/no-unsafe-return
                    return p;
                }
            });
            fn.parameters = parameters;
            return new Sender(() => {
                subscribed.forEach((key) => this.subscriptions.delete(key));
            }, () => new Promise(function (resolve, reject) {
                self.callbacks.set(asKey(messageId), (result) => {
                    if (result.success) {
                        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
                        resolve(result.value);
                    }
                    else if (result.value instanceof Error) {
                        reject(result.value);
                    }
                    else {
                        reject(new Error(JSON.stringify(result.value)));
                    }
                });
                const message = new Message(messageId, fn);
                self.worker.postMessage(message);
            }));
        };
        this.onMessage = (message) => {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
            const data = Message.asReturn(message.data ?? message);
            if (!data) {
                throw new UnmanagedMessage(JSON.stringify(message));
            }
            else {
                const result = data.payload;
                const callback = this.callbacks.get(asKey(data.id));
                if (callback) {
                    this.callbacks.delete(asKey(data.id));
                    callback(data.payload);
                    return;
                }
                const subscription = this.subscriptions.get(asKey(data.id));
                if (subscription) {
                    subscription(data.payload);
                    return;
                }
                if (result.value instanceof Error) {
                    throw result.value;
                }
                else
                    throw new Error("Return with no callback" + JSON.stringify(data));
            }
        };
        this.worker.onMessage(this.onMessage);
    }
}
function apply(post, id, caller, fn, parameters, conv = (v) => 
// eslint-disable-next-line @typescript-eslint/no-unsafe-return
v) {
    try {
        const promise = fn.apply(caller, parameters);
        promise
            .then((result) => {
            post(new Message(id, new Return(true, conv(result))));
        })
            .catch((e) => {
            // Firefox doesn't transmit Worker message if an object of type Error is in the message.
            post(new Message(id, new Return(false, e instanceof Error ? e.message : e)));
        });
    }
    catch (e) {
        post(new Message(id, new Return(false, e instanceof Error ? e.message : e)));
    }
}
let runner;
let wrappedId = 0;
const wrapped = new Map();
export const onWorkerMessage = (message, post, creator) => {
    let data = Message.asCaller(message);
    if (!data) {
        data = Message.asFunction(message);
        if (!data) {
            post("Invalid worker message");
        }
        else {
            const fun = data.payload;
            const parameters = fun.parameters.map((p) => {
                const subscription = typeof p == "object" ? MessageId.as(p) : null;
                if (subscription) {
                    return (...args) => {
                        post(new Message(subscription, new Return(true, args)));
                    };
                }
                else {
                    // eslint-disable-next-line @typescript-eslint/no-unsafe-return
                    return p;
                }
            });
            if (fun.fn == creator.getName()) {
                if (runner) {
                    post(new Message(data.id, new Return(false, creator.getType() + " already created")));
                }
                else {
                    apply(post, data.id, creator, creator.create, parameters, (created) => {
                        runner = created;
                        return null;
                    });
                }
            }
            else if (!runner) {
                post(new Message(data.id, new Return(false, "Database must be created")));
            }
            else {
                // @ts-expect-error: Element implicitly has an 'any' type because expression of type 'string' can't be used to index type '{}'.
                const fn = runner[fun.fn];
                if (typeof fn !== "function") {
                    post(new Message(data.id, new Return(false, "Invalid database function " + fun.fn)));
                }
                else {
                    const fn_at_assumed_type = fn;
                    apply(post, data.id, runner, fn_at_assumed_type, parameters, (result) => {
                        if (fun.wrap?.wrap) {
                            const wId = wrappedId++;
                            wrapped.set(wId, {
                                value: result,
                                autoremove: fun.wrap.autoremove,
                            });
                            if (result instanceof Wrappable) {
                                result.wrappedId = wId;
                            }
                            result = new Wrapped(wId);
                        }
                        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
                        return result;
                    });
                }
            }
        }
    }
    else {
        const caller = data.payload;
        const parameters = caller.parameters.map((p) => {
            const subscription = typeof p == "object" ? MessageId.as(p) : null;
            if (subscription) {
                return (...args) => {
                    post(new Message(subscription, new Return(true, args)));
                };
            }
            else {
                // eslint-disable-next-line @typescript-eslint/no-unsafe-return
                return p;
            }
        });
        const obj = wrapped.get(caller.wrapped);
        const fni = caller.fn == ""
            ? { fn: obj?.value, obj: null }
            : { fn: obj?.value[caller.fn], obj: obj?.value };
        if (typeof fni.fn !== "function") {
            post(new Message(data.id, new Return(false, "Invalid function " + caller.fn)));
        }
        else {
            const fn_at_assumed_type = fni.fn;
            apply(post, data.id, fni.obj, fn_at_assumed_type, parameters);
        }
        if (obj?.autoremove || caller.remove) {
            wrapped.delete(caller.wrapped);
        }
    }
};
//# sourceMappingURL=sk_worker.js.map