import type { int } from "@skiplang/std";
import type { Wrk } from "./sk_types.js";
export declare class Wrappable {
    wrappedId?: int;
}
export declare class Function {
    fn: string;
    parameters: any[];
    wrap?: {
        wrap: boolean;
        autoremove: boolean;
    } | undefined;
    constructor(fn: string, parameters: any[], wrap?: {
        wrap: boolean;
        autoremove: boolean;
    } | undefined);
    static as(obj: object): Function | null;
    static isValid(obj: object): obj is object & Record<"fn", unknown> & Record<"parameters", unknown>;
}
export declare class Caller {
    wrapped: number;
    fn: string;
    parameters: any[];
    remove: boolean;
    constructor(wrapped: number, fn: string, parameters: any[], remove?: boolean);
    static convert(obj: object): Caller | null;
    static isValid(obj: object): obj is object & Record<"fn", unknown> & Record<"parameters", unknown>;
}
export declare class Return {
    success: boolean;
    value: any;
    constructor(success: boolean, value: any);
    static as(obj: object): Return | null;
}
export declare class MessageId {
    source: number;
    id: number;
    constructor(source: number, id: number);
    static as(obj: object): MessageId | null;
}
export declare class Wrapped {
    wrapped: number;
    constructor(wrapped: number);
    static as(obj: object): Wrapped | null;
}
export declare class Sender {
    close: () => void;
    send: <T>() => Promise<T>;
    constructor(close: () => void, send: <T>() => Promise<T>);
}
export declare class Message {
    id: MessageId;
    payload: unknown;
    constructor(id: MessageId, payload: unknown);
    private static convert;
    static asFunction(obj: object): Message | null;
    static asCaller(obj: object): Message | null;
    static asReturn(obj: object): Message | null;
}
export declare class PromiseWorker {
    private lastId;
    private source;
    private worker;
    private callbacks;
    private subscriptions;
    post: (fn: Function) => Sender;
    onMessage: (message: MessageEvent) => void;
    constructor(worker: Wrk);
}
export interface Creator<T> {
    getName: () => string;
    getType: () => string;
    create: (...args: any[]) => Promise<T>;
}
export declare const onWorkerMessage: <T>(message: MessageEvent, post: (message: any) => void, creator: Creator<T>) => void;
//# sourceMappingURL=sk_worker.d.ts.map