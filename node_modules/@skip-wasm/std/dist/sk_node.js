import { MemFS, MemSys } from "./sk_mem_utils.js";
import * as path from "path";
import * as fsPromises from "fs/promises";
import * as util from "util";
import * as perf_hooks from "perf_hooks";
import * as crypto from "crypto";
import { Worker } from "worker_threads";
class WrkImpl {
    constructor(worker) {
        this.worker = worker;
        this.postMessage = (message) => {
            this.worker.postMessage(message);
        };
        this.onMessage = (listener) => {
            this.worker.on("message", listener);
        };
    }
    static fromPath(url, options) {
        const filename = "./" + path.relative(process.cwd(), url.pathname);
        return new this(new Worker(filename, options));
    }
}
const decoder = new util.TextDecoder("utf8");
const encoder = new util.TextEncoder();
class Env {
    fs() {
        return this.fileSystem;
    }
    sys() {
        return this.system;
    }
    name() {
        return "node";
    }
    fetch(url) {
        let filename;
        const cwd = process.cwd();
        if (url && url instanceof URL && url.pathname) {
            filename = "./" + path.relative(cwd, url.pathname);
        }
        else if (url != "" &&
            // @ts-expect-error: Property 'default' does not exist on type 'string | URL'.
            url.default) {
            // @ts-expect-error: Property 'default' does not exist on type 'string | URL'.
            filename = "./" + path.relative(cwd, url.default);
        }
        else {
            filename = url;
        }
        return fsPromises.readFile(filename);
    }
    onException() {
        /* default nop hook */
    }
    constructor(environment) {
        this.disableWarnings = false;
        this.shared = new Map();
        this.fileSystem = new MemFS();
        this.system = new MemSys();
        this.timestamp = () => perf_hooks.performance.now();
        this.decodeUTF8 = (v) => decoder.decode(v);
        this.encodeUTF8 = (v) => encoder.encode(v);
        this.environment = environment ?? [];
        this.base64Decode = (base64) => Buffer.from(base64, "base64");
        this.base64Encode = (toEncode, url = false) => Buffer.from(toEncode).toString(url ? "base64url" : "base64");
        this.throwRuntime = (code) => {
            this.onException();
            process.exit(code);
        };
        this.createSocket = (url) => new WebSocket(url);
        this.createWorker = (url, options) => WrkImpl.fromPath(url, options);
        this.createWorkerWrapper = (_worker) => {
            throw new Error("Not implemented");
        };
        this.crypto = () => crypto;
    }
}
export function environment(environment) {
    return new Env(environment);
}
//# sourceMappingURL=sk_node.js.map