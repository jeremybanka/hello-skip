import type * as Internal from "@skiplang/std/internal.js";
import type { Pointer, float, int, Nullable } from "@skiplang/std";
export type { float, int, Nullable, Pointer };
export type ptr<InternalType extends Internal.T<any>> = Internal.Opaque<number, InternalType> & Pointer<InternalType>;
export declare function toPtr<T extends Internal.T<any>>(pointer: Pointer<T>): ptr<T>;
export declare function toNullablePtr<T extends Internal.T<any>>(pointer: Nullable<Pointer<T>>): Nullable<ptr<T>>;
export declare function toNullablePointer<T extends Internal.T<any>>(ptrVal: Nullable<ptr<T>>): Nullable<Pointer<T>>;
export declare enum Stream {
    OUT = 0,
    ERR = 1,
    DEBUG = 2
}
export declare class State {
    exceptionId: number;
    exceptions: Map<number, Exception>;
}
export declare class Exception {
    id: int;
    err: Error;
    constructor(err: Error, state: State);
}
export interface Shared {
    getName: () => string;
}
export declare class Options {
    read: boolean;
    write: boolean;
    append: boolean;
    truncate: boolean;
    create: boolean;
    create_new: boolean;
    constructor(read?: boolean, write?: boolean, append?: boolean, truncate?: boolean, create?: boolean, create_new?: boolean);
    static w(): Options;
    toFlags(): number;
    static fromFlags(flags: int): Options;
}
export interface FileSystem {
    openFile(filename: string, flags: Options, mode: int): number;
    closeFile(fd: int): void;
    watchFile(filename: string, f: (change: string) => void): void;
    writeToFile(fd: int, content: string): void;
    appendToFile(filename: string, content: string): void;
    write(fd: int, content: string): int;
    read(fd: int, len: int): string | null;
    exists(filename: string): boolean;
}
export interface System {
    setenv(name: string, value: string): void;
    getenv(name: string): string | null;
    unsetenv(name: string): void;
}
export interface Wrk {
    postMessage: (message: any) => void;
    onMessage: (listener: (value: any) => void) => void;
}
export interface Environment {
    shared: Map<string, Shared>;
    name: () => string;
    disableWarnings: boolean;
    environment: string[];
    createSocket: (url: string) => WebSocket;
    createWorker: (url: URL, options?: WorkerOptions) => Wrk;
    createWorkerWrapper: (worker: Worker) => Wrk;
    timestamp: () => float;
    decodeUTF8: (utf8: ArrayBuffer) => string;
    encodeUTF8: (str: string) => Uint8Array;
    onException: () => void;
    base64Decode: (base64: string) => Uint8Array;
    base64Encode: (toEncode: string, url?: boolean) => string;
    fs: () => FileSystem;
    sys: () => System;
    crypto: () => Crypto;
    fetch: (url: URL | string) => Promise<Uint8Array | ArrayBuffer>;
}
export interface Memory {
    buffer: ArrayBuffer;
}
export interface WasmSupplier {
    completeWasm: (wasm: object, utils: Utils) => void;
}
export type Main = (new_args: string[], new_stdin: string) => string;
export type App = {
    environment: Environment;
    main: Main;
};
export declare class Utils {
    private readonly exports;
    private readonly env;
    private readonly state;
    private readonly states;
    args: string[];
    private current_stdin;
    private stdin;
    private stdout;
    private stderr;
    private stddebug;
    private readonly mainFn?;
    private exception?;
    private stacks;
    exit: (code: int) => never;
    constructor(exports: WebAssembly.Exports, env: Environment, mainFn?: string);
    log: (str: string, kind?: Stream, newLine?: boolean) => void;
    sklog: (strPtr: ptr<Internal.String>, kind?: Stream, newLine?: boolean) => void;
    clearMainEnvironment: (new_args?: string[], new_stdin?: string) => void;
    runCheckError: <T>(fn: () => T) => T;
    main: (new_args: string[], new_stdin: string) => string;
    importOptString: (strPtr: ptr<Internal.String>) => string | null;
    importString: (strPtr: ptr<Internal.String>) => string;
    exportString: (s: string) => ptr<Internal.String>;
    importBytes: (skArray: ptr<Internal.Array<Internal.Byte>>, sizeof?: int) => Uint8Array<ArrayBuffer>;
    importBytes2: (skBytes: ptr<Internal.T<any>>, size?: int) => Uint8Array<ArrayBuffer>;
    exportBytes: (view: Uint8Array) => ptr<Internal.Array<Internal.Byte>>;
    exportBytes2: (view: Uint8Array, skBytes: ptr<Internal.T<any>>) => void;
    importUInt32s: (skArray: ptr<Internal.Array<Internal.UInt32>>) => Uint32Array<ArrayBuffer>;
    exportUInt32s(array: Uint32Array): ptr<Internal.Array<Internal.UInt32>>;
    importFloats: (skArray: ptr<Internal.Array<Internal.Float>>) => Float64Array<ArrayBuffer>;
    exportFloats(array: Float64Array): ptr<Internal.Array<Internal.Float>>;
    call: <Ret>(fnId: ptr<Internal.Function<Internal.Void, Internal.T<Ret>>>) => ptr<Internal.T<Ret>>;
    callWithException: <Ret>(fnId: ptr<Internal.Function<Internal.Void, Internal.T<Ret>>>, exception: Exception | null) => ptr<Internal.T<Ret>>;
    getBytesFromBuffer: (dataPtr: ptr<Internal.T<any>>, length: int) => Uint8ClampedArray<ArrayBuffer>;
    init: () => void;
    etry: <Ret>(f: ptr<Internal.Function<Internal.Void, Internal.T<Ret>>>, exn_handler: ptr<Internal.Function<Internal.Void, Internal.T<Ret>>>) => ptr<Internal.T<Ret>>;
    ethrow: (skExc: ptr<Internal.Exception>, rethrow: boolean) => never;
    replace_exn(oldex: ptr<Internal.Exception>, newex: ptr<Internal.Exception>): void;
    deleteException: (exc: int) => void;
    getExceptionMessage: (exc: int) => string;
    getExceptionStack: (exc: int) => string;
    getErrorObject: (skExc: ptr<Internal.Exception>) => Error;
    getPersistentSize: () => number;
    getVersion: () => number;
    getMemoryBuffer: () => ArrayBuffer;
    readStdInLine: () => number[];
    readStdInToEnd: () => number[];
    runWithGc: <T>(fn: () => T) => T;
    getState<T>(name: string, create: () => T): T;
}
export interface Links {
    complete: (utils: Utils, exports: object) => void;
}
export interface ToWasmManager {
    prepare: (wasm: object) => Links | null;
}
export type ModuleInit = (e: Environment) => Promise<ToWasmManager>;
export type EnvInit = (e: Environment) => void;
export interface Text {
    toJSON: () => object;
}
export declare class Raw implements Text {
    private readonly text;
    constructor(text: string, _category?: string);
    toJSON: () => object;
}
export declare class Locale implements Text {
    private readonly text;
    private readonly category;
    constructor(text: string, category?: Nullable<string>);
    toJSON: () => object;
}
export declare const l: (text: string, category?: string) => Locale;
export declare const f: (format: Text | string, parameters: (Text | string)[]) => Format;
export declare const check: (value: Text | string) => Text;
export declare class Format implements Text {
    private readonly format;
    private readonly parameters;
    constructor(format: Text | string, parameters: (Text | string)[]);
    toJSON: () => object;
}
export declare function resolve(path: string): string;
export declare function trimEndChar(str: string, ch: string): string;
export declare function humanSize(bytes: int): string;
export declare function loadWasm(buffer: ArrayBuffer, managers: ToWasmManager[], environment: Environment, main?: string): Promise<{
    environment: Environment;
    main: (new_args: string[], new_stdin: string) => string;
}>;
export declare function isNode(): boolean;
export declare function loadEnv(extensions: EnvInit[], envVals?: string[]): Promise<Environment>;
export type Metadata = {
    filepath: string;
    line: number;
    column: number;
};
/**
 * Collect function script metadata (name, line, colum)
 * @param offset The offset of the function for the one to collect metadata
 * @returns The script metadata of the offset function
 */
export declare function metadata(offset: number): Metadata;
export declare function run(wasmUrl: URL | (() => URL | string | Promise<URL | string>), modules: ModuleInit[], extensions: EnvInit[], main?: string, getWasmSource?: () => Promise<Uint8Array>): Promise<{
    environment: Environment;
    main: (new_args: string[], new_stdin: string) => string;
}>;
//# sourceMappingURL=sk_types.d.ts.map